# Usage with Ecto

```elixir
Mix.install([
  {:sqlite_vec, path: "../sqlite_vec"},
  {:ecto, "~> 3.12"},
  {:ecto_sql, "~> 3.12"},
  {:ecto_sqlite3, "~> 0.17.2"},
  {:kino, "~> 0.14.1"},
  {:nx, "~> 0.9.1"}
])
```

## Setup

You can load the extension in the runtime configuration like so:

<!-- livebook:{"force_markdown":true} -->

```elixir
config :ecto_sqlite3, load_extensions: [SqliteVec.path()]
```

<!-- livebook:{"break_markdown":true} -->

Next, we must define our Repo.

```elixir
defmodule MyApp.Repo do
  use Ecto.Repo,
    otp_app: :my_app,
    adapter: Ecto.Adapters.SQLite3
end

db_path = Path.join(__DIR__, "demo.db")
Kino.start_child({MyApp.Repo, database: db_path, load_extensions: [SqliteVec.path()]})
```

## With a regular table

```elixir
defmodule MyApp.Repo.Migrations.CreateEmbeddingsTable do
  use Ecto.Migration

  def up do
    execute("CREATE TABLE embeddings(id INTEGER PRIMARY KEY, embedding float[4], metadata TEXT)")
  end

  def down do
    execute("DROP TABLE embeddings") 
  end
end
```

```elixir
Ecto.Migrator.up(MyApp.Repo, 1, MyApp.Repo.Migrations.CreateEmbeddingsTable)
```

Schema definition:

```elixir
defmodule Embedding do
  use Ecto.Schema

  schema "embeddings" do
    field(:embedding, SqliteVec.Ecto.Float32)
    field(:metadata, :string)
  end
end
```

Insert some vectors:

```elixir
MyApp.Repo.insert(%Embedding{embedding: SqliteVec.Float32.new([1, 2, 3, 4]), metadata: "from constructor"})
MyApp.Repo.insert(%Embedding{embedding: [3, 4, 5, 6], metadata: "from list"})
MyApp.Repo.insert(%Embedding{embedding:  Nx.tensor([3, 4, 5, 6], type: :f32), metadata: "from tensor"})
```

Query them:

```elixir
import Ecto.Query
import SqliteVec.Ecto.Query

v = SqliteVec.Float32.new([2, 2, 3, 3])

MyApp.Repo.all(
  from(i in Embedding,
    order_by: l2_distance(i.embedding, vec_f32(^v.data))
  )
)
```

## With a virtual table

Then, we can run a migration to create the virtual table where we store vectors.

```elixir
defmodule MyApp.Repo.Migrations.CreateVirtualEmbeddingsTable do
  use Ecto.Migration

  def up do
    execute("CREATE VIRTUAL TABLE virtual_embeddings_table USING vec0(id INTEGER PRIMARY KEY, embedding float[2])")
  end

  def down do
    execute("DROP VIRTUAL TABLE virtual_embeddings_table")
  end
end
```

```elixir
Ecto.Migrator.up(MyApp.Repo, 2, MyApp.Repo.Migrations.CreateVirtualEmbeddingsTable)
```

```elixir
defmodule VirtualEmbedding do
  use Ecto.Schema

  schema "virtual_embeddings_table" do
    field(:embedding, SqliteVec.Ecto.Float32)
  end
end
```

```elixir
MyApp.Repo.insert_all(VirtualEmbedding, [
  [embedding: [0, 0]],
  [embedding: [1, 1]],
  [embedding: [2, 3]]
])
```

```elixir
import Ecto.Query
import SqliteVec.Ecto.Query

v = SqliteVec.Float32.new([2, 2])

MyApp.Repo.all(
  from(i in VirtualEmbedding,
    order_by: l2_distance(i.embedding, vec_f32(^v.data))
  )
)
```
